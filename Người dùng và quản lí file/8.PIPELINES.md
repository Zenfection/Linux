# PIPELINES

## 1.Tiêu chuẩn hệ thống `stdin`,`stdout` và `stderr`

Trong Unix, khi chương trình muốn mở một file để đọc hoặc ghi. Nó bắt buộc phải đạt được **"file descriptor"** từ hệ điều hành. Hệ điều hành theo dõi file đó.

Mọi quá trình sẽ tự động giãi mã 3 file descriptor mặc định gọi là **`stdin`** (standard input),**`stdout`** (standard output) và **`stderr`** (standard error). Ba file descriptor đó gọi là chung là **"standard steams"**.

Một Pipeline là một tập hợp các [tiến trình được](https://vi.wikipedia.org/wiki/Ti%E1%BA%BFn_tr%C3%ACnh "Tiến trình") nối với nhau bởi các luồng tiêu chuẩn của chúng, sao cho văn bản đầu ra của mỗi tiến trình **`stdout`** được truyền trực tiếp dưới dạng đầu vào **`stdin`** tới tiến trình kế tiếp

Những thứ khó hiểu trên nói cho nó dễ hiểu là: **`stdin`** là những thứ gì nhập vào chương trình, còn **`stdout`** là những thứ xuất ra màn hình.

---

## 2. Những điều cơ bản của Pipe Operator

Trong Unix, mọi quá trình đều có ba luồng tiêu chuẩn: **`stdin`**,**`stdout`**, và **`stderr`**. Bởi mặc định bất kỳ quá trình ghi **`stdout`** sẽ xuất hiện dưới dạng văn bản **console**.

Tuy nhiên, chúng ta có thể làm cho nó để một quá trình **`stdout`** được đính kèm một quá trình **`stdin`** để sản xuất ra **"pipeline"**.

Để làm điều đó, chúng ta sử dụng dấu **`|`** (ký tự pipeline hay còn gọi là đường ống). Nhìn ví dụ sau đây:

```shell
$ ps ax | grep mysql
2922 ?       S      0:00
     /bin/sh /usr/bin/mysqld_safe
3164 ?       SL   204:21
     /usr/sbin/mysqld
$
```

Lệnh **`px ax`** ghi một danh sách các tiến trình hiện đang chạy đến **`stdout`**. Lệnh **`grep mysql`** đọc tử **`stdin`** và ghi tất cả những dòng nhập chứa **"mysql"** đến **`stdout`**.

Cùng với nó, chúng ta có thể nhận "pipeline" duy nhất liệt kê các tiến trình hiện đang chạy với tên chứa **"mysql"**.Điều quan trọng là **`ps`** và **`grep`** cả 2 liên quan với nhau trong quá trình **`stdin`** và **`stdout`**. Hệ điều hành gộp 2 quá trình này lại với nhau bằng dấu **`|`**.

---

## 3. Nhập và xuất với dấu chuyển hướng  `<` và `>`

Dấu **`|`** cho phép gộp **`stdout`** của một tiến trình đến **`stdin`** của một tiến trình khác. Tuy nhiên, nó cũng có thể làm **`stdout`** trỏ trực tiếp đến tệp, nên là mọi thứ được ghi vào **`stdout`** thực chất đã được gọi vào file. Chúng ta có thể dùng tương tự như thế cho **`stdin`**, nên những nội dung của files được đọc tự động như đầu vào.

Để làm điều này bạn sử dụng dấu chuyển hướng **`<`** và **`>`**.

Muốn nhập và vào một file, ta sử dụng như sau:

```shell
$ ps aux > ps_output.txt
```

Nó sẽ ghi output của **`ps aux`** đến file **`ps_output.txt`** trên directory hiện tại (trong khi đó thông thường nó sẽ xuất ra màn hình). Lệnh **`ps`** chính nó không biết rằng nó thực chất đang ghi trên file. Bên trong nó đơn giản là "stardard output".

Nếu muốn xuất ra một file, sử dụng dấu **`<`** như sau:

```shell
$ sort < words.txt
```

Ở đây, Lệnh **`sort`** sẽ đọc **`stdin`** trước khi nó xem đến cuối cùng của file đánh dấu và sắp xếp các dòng theo chữ cái, ghi lại những sắp xếp đó xuất ra **`stdout`**.

Dấu **`>`** phổ biến hơn nhiều so với dấu **`<`** bởi vì có rất nhiều chương trình có thể hỗ trợ trực tiếp 1 file đầu vào làm đối số. 

**Ví dụ:** `sort words.txt` sẽ hoạt động cũng như `sort < words.txt`. Tuy nhiên nếu chỉ có **`sort`** nó sẽ hỗ trợ đọc từ **`stdin`**, ta có thể sử dụng dấu **`<`** để đọc file.

### Vấn đề với **`cat file |...`**

```shell
$ cat some_file.txt | some_command
```

**`some_file.txt`** thì bạn có thể add bất kỳ file nào còn **`some_command`** thì bạn có thể sử dụng bất kỳ tiến trình nào. Lệnh **`cat`** sẽ ghi những nội dung từ **`some_file.txt`** đến **`stdout`** trong khi dấu **`|`** sẽ dán **`some_command`** vào **`stdin`**.

Sử dụng **`cat`** và **`|`** là dư thừa trong khi chỉ cần sử dụng dấu **`<`** như sau:

```shell
$ some_command < some_file.txt
```

---






